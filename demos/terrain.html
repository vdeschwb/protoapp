<!DOCTYPE HTML>
<HTML>
 <HEAD>
  <TITLE>Terrain Prototype</TITLE>
  <META NAME="Author" CONTENT="TBD">

  <link rel="stylesheet" type="text/css" href="terrain.css">

 </HEAD>

 <BODY>

 	<div class='header'>
 		Terrain Prototype
 		<div style="font-size:12pt;">
 			v 0.1
 		</div>
 	</div>

 	<table class='settings'>
 		<tr>
 			<td>
 				<input id="texture_checkbox" type="checkbox" checked="true" onclick="texture_checkbox_click();"> Texture

 					<select id="texture_select">
					  	<option value="eiger_topo_1.jpg">TOPO 1</option>
					  	<option value="eiger_topo_2.jpg">TOPO 2</option>
					  	<option value="eiger_google_1.jpg" selected="true">GOOGLE 1</option>
					</select>
 			</td>
 			<td>
 				<input id="animate_checkbox" type="checkbox" checked="true" onclick="animate_checkbox_click();"> Animate
 			</td>
 			<td>
 				Step: <select id="step_select">
				  	<option value="1">1</option>
				  	<option value="2" selected="true">2</option>
				  	<option value="4">4</option>
				  	<option value="8">8</option>
				  	<option value="16">16</option>
				  	<option value="32">32</option>
				  	<option value="64">64</option>
				  	<option value="128">128</option>
				  	<option value="256">256</option>
				  	<option value="512">512</option>
				</select>
 			</td>
 			<td>
 				<button onclick="generate();">Generate</button>
 			</td>
 		</tr>
 	</table>

 	<div id="canvas_container" style="display:block; height:100%;">
		<canvas id="cv"/>
	</div>


	<script type="text/javascript" src="../jsc3d.js"></script>
	<script type="text/javascript" src="../jsc3d.touch.js"></script>
	<script type="text/javascript" src="../jsc3d.webgl.js"></script>
	<script type="text/javascript">


	var step_select = document.getElementById('step_select');
	var texture_checkbox = document.getElementById('texture_checkbox');
	function texture_checkbox_click() {
		if (texture_checkbox.checked) {
			mesh.setTexture(texture);
		} else {
			mesh.setTexture(null);
		}
		viewer.update();
	};

	var animate_checkbox = document.getElementById('animate_checkbox');
	function animate_checkbox_click() {
		update();
	}

	var canvas = document.getElementById('cv');
	var viewer = new JSC3D.Viewer(canvas);
	var rotation = {'x':15, 'y': 90, 'z': 0};
	viewer.setParameter('SceneUrl', '');
	viewer.setParameter('InitRotationX', rotation.x);
	viewer.setParameter('InitRotationY', rotation.y);
	viewer.setParameter('InitRotationZ', rotation.z);
	viewer.setParameter('ModelColor', '#AAAAAA');
	viewer.setParameter('BackgroundColor1', '#FFFFFF');
	viewer.setParameter('BackgroundColor2', '#AAAAAA');
	viewer.setParameter('FaceCulling', 'off');
	viewer.setParameter('RenderMode', 'texturesmooth');
	viewer.setParameter('Renderer', 'webgl');
	viewer.setMouseUsage('free');
	viewer.init();

	var mouse_down = null;
	viewer.onmousedown = function (x, y) {
		console.log("Mouse down: ", x, y);
		mouse_down = {'x': x, 'y': y};
	};

	viewer.onmouseup = function (x, y) {
		console.log("Mouse up: ", x, y)
		mouse_down = null;
	};

	function apply_rotation() {
		viewer.rotMatrix.identity();
		viewer.rotMatrix.rotateAboutYAxis(rotation.y);
		viewer.rotMatrix.rotateAboutXAxis(rotation.x);
		viewer.rotMatrix.rotateAboutZAxis(rotation.z);
	}

	viewer.onmousemove = function (x, y) {
		console.log(x, y);
		if (mouse_down) {
			var dx = (y - mouse_down.y) * 0.1;
			var dy = (x - mouse_down.x) * 0.1;
			viewer.rotMatrix.identity();
			rotation.x += dx;
			rotation.y += dy;
			apply_rotation();
			mouse_down = {'x': x, 'y': y};
		}
	};
	viewer.update();


	(function() {
    var canvas_container = document.getElementById('canvas_container');
    // resize the canvas to fill browser window dynamically
    window.addEventListener('resize', resizeCanvas, false);

    function resizeCanvas() {
    		// canvas_container.width = window.innerWidth;
    		// canvas_container.height = window.innerHeight;
            canvas.width = canvas_container.clientWidth;
            canvas.height = canvas_container.clientHeight;

            /**
             * Your drawings need to be inside this function otherwise they will be reset when 
             * you resize the browser window and the canvas goes will be cleared.
             */
            drawStuff(); 
    }
    resizeCanvas();

    function drawStuff() {
            viewer.update();
    }
})();


function update() {
	if (mouse_down == null && animate_checkbox.checked) {
		viewer.rotMatrix.identity();
		rotation.x += 0;
		rotation.y += 0.025;
		rotation.z += 0;
		viewer.rotMatrix.rotateAboutYAxis(rotation.y);
		viewer.rotMatrix.rotateAboutXAxis(rotation.x);
		viewer.rotMatrix.rotateAboutZAxis(rotation.z);
		// viewer.rotate(rotation.x, rotation.y, rotation.z);
		viewer.update();
	}
	setTimeout(update, 10);
}

	ElevationGrid = function(name) {
		this.name = (name != null) ? name : 'noname';
		this.xDim = 0;
		this.zDim = 0;
		this.xSpacing = 0;
		this.zSpacing = 0;
		this.heights = [];
		this.textureUrl = '';
		this.onDataLoaded = null;

		this.toMesh = function() {
			var mesh = new JSC3D.Mesh;
			mesh.name = this.name;
			if( this.xDim > 1 && this.zDim > 1 && 
				this.heights.length >= this.xDim * this.zDim ) {

				mesh.vertexBuffer = new Array(this.xDim * this.zDim * 3);
				var k = 0;
				for(var i=0; i<this.zDim; i++) {
					for(var j=0; j<this.xDim; j++) {
						mesh.vertexBuffer[k++] = j * this.xSpacing;
						mesh.vertexBuffer[k++] = this.heights[j + i * this.xDim];
						mesh.vertexBuffer[k++] = i * this.zSpacing;
					}
				}

				mesh.indexBuffer = new Array((this.xDim - 1) * (this.zDim - 1) * 4);
				k = 0;
				for(var i=0; i<this.zDim-1; i++) {
					for(var j=0; j<this.xDim-1; j++) {
						mesh.indexBuffer[k++] = j + i * this.xDim;
						mesh.indexBuffer[k++] = j + (i + 1) * this.xDim;
						mesh.indexBuffer[k++] = j + 1 + i * this.xDim;
						mesh.indexBuffer[k++] = -1;
						mesh.indexBuffer[k++] = j + (i + 1) * this.xDim;
						mesh.indexBuffer[k++] = j + 1 + (i + 1) * this.xDim;
						mesh.indexBuffer[k++] = j + 1 + i * this.xDim;
						mesh.indexBuffer[k++] = -1;
					}
				}

				if(this.textureUrl != '') {
					mesh.texCoordBuffer = new Array(this.xDim * this.zDim * 2);
					k = 0;
					for(var i=0; i<this.zDim; i++) {
						for(var j=0; j<this.xDim; j++) {
							mesh.texCoordBuffer[k++] = j / (this.xDim - 1);
							mesh.texCoordBuffer[k++] = i / (this.zDim - 1);
						}
					}

					mesh.texCoordIndexBuffer = mesh.indexBuffer;

					texture.onready = function() {
						mesh.setTexture(this);
						viewer.update();
					};
					texture.createFromUrl(this.textureUrl);
				}
			}

			return mesh;
		};

		this.loadFromFile = function(filename) {
			var xhr;
			if (window.XMLHttpRequest) {
			    xhr = new XMLHttpRequest();
			} else if (window.ActiveXObject) {
			    xhr = new ActiveXObject("Microsoft.XMLHTTP");
			}

			xhr.parent = this;

			xhr.onreadystatechange = function(){ 
				if (xhr.readyState == 4 && xhr.status == 200) {
					console.log("DATA LOADED");
					this.parent.heights = [];
					var lines = xhr.responseText.split('\n');
					for (var line = 0; line<lines.length; line+=step) {
						var data = lines[line].split(',');
						for (var i = 0; i < data.length-1; i+=step) {
							this.parent.heights.push((parseFloat(data[i]))/20);
						};
					}
					if (this.parent.onDataLoaded != null) {
						console.log("ODL");
						this.parent.onDataLoaded();
					}
				}
			};
			xhr.open("GET", filename);
			xhr.send();
		};
	};

	var terrain;
	var step;
	var mesh;
	var texture;
	var mat;

	function generate() {
		step = parseInt(step_select.options[step_select.selectedIndex].value);
		terrain = new ElevationGrid('terrain');
		terrain.xDim = 1024/step;
		terrain.zDim = 1024/step;
		terrain.xSpacing = .2*step;
		terrain.zSpacing = .2*step;
		terrain.textureUrl = texture_select.options[texture_select.selectedIndex].value;

		mesh = null;
		texture = new JSC3D.Texture;
		mat = new JSC3D.Material();
		terrain.onDataLoaded = function() {

			mesh = terrain.toMesh();
			mat.simulateSpecular = true;
			mat.diffuseColor = 0xFFFFFF;
			mat.transparency = 0;
			mesh.setMaterial(mat);

			scene = new JSC3D.Scene();
			scene.addChild(mesh);
			viewer.replaceScene(scene);


			viewer.zoomFactor = 0.8;
			update();
			apply_rotation();
		};

		terrain.loadFromFile('eiger_height.dat');
	}

	generate();

  </script>
 </BODY>
</HTML>
