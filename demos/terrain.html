<!DOCTYPE HTML>
<HTML>
 <HEAD>
  <TITLE>Terrain Prototype</TITLE>
  <META NAME="Author" CONTENT="TBD">

  <link rel="stylesheet" type="text/css" href="terrain.css">

 </HEAD>

 <BODY>

 	<div class='header'>
 		Terrain Prototype
 		<div style="font-size:12pt;">
 			v 0.1
 		</div>
 	</div>

 	<div id="canvas_container" style="display:block; height:100%;">
		<canvas id="cv"</canvas>
	</div>
	<script type="text/javascript" src="../jsc3d.js"></script>
	<script type="text/javascript" src="../jsc3d.touch.js"></script>
	<script type="text/javascript" src="../jsc3d.webgl.js"></script>
	<script type="text/javascript">
	var canvas = document.getElementById('cv');
	var viewer = new JSC3D.Viewer(canvas);
	var rotation = {'x':15, 'y': 0, 'z': 0};
	viewer.setParameter('SceneUrl', '');
	viewer.setParameter('InitRotationX', rotation.x);
	viewer.setParameter('InitRotationY', rotation.y);
	viewer.setParameter('InitRotationZ', rotation.z);
	viewer.setParameter('ModelColor', '#CAA618');
	viewer.setParameter('BackgroundColor1', '#FFFFFF');
	viewer.setParameter('BackgroundColor2', '#AAAAAA');
	viewer.setParameter('FaceCulling', 'off');
	viewer.setParameter('RenderMode', 'texturesmooth');
	viewer.setParameter('Renderer', 'webgl');
	viewer.setMouseUsage('free');
	viewer.init();

	var mouse_down = null;
	viewer.onmousedown = function (x, y) {
		console.log("Mouse down: ", x, y);
		mouse_down = {'x': x, 'y': y};
	};

	viewer.onmouseup = function (x, y) {
		console.log("Mouse up: ", x, y)
		mouse_down = null;
	};

	viewer.onmousemove = function (x, y) {
		console.log(x, y);
		if (mouse_down) {
			var dx = (y - mouse_down.y) * 0.1;
			var dy = (x - mouse_down.x) * 0.1;
			viewer.rotMatrix.identity();
			rotation.x += dx;
			rotation.y += dy;
			viewer.rotMatrix.identity();
			viewer.rotMatrix.rotateAboutYAxis(rotation.y);
			viewer.rotMatrix.rotateAboutXAxis(rotation.x);
			viewer.rotMatrix.rotateAboutZAxis(rotation.z);
			mouse_down = {'x': x, 'y': y};
		}
	};
	viewer.update();


	(function() {
    var canvas = document.getElementById('cv');
    var canvas_container = document.getElementById('canvas_container');
    // resize the canvas to fill browser window dynamically
    window.addEventListener('resize', resizeCanvas, false);

    function resizeCanvas() {
    		// canvas_container.width = window.innerWidth;
    		// canvas_container.height = window.innerHeight;
            canvas.width = canvas_container.clientWidth;
            canvas.height = canvas_container.clientHeight;

            /**
             * Your drawings need to be inside this function otherwise they will be reset when 
             * you resize the browser window and the canvas goes will be cleared.
             */
            drawStuff(); 
    }
    resizeCanvas();

    function drawStuff() {
            viewer.update();
    }
})();


function update() {
	if (mouse_down == null) {
		viewer.rotMatrix.identity();
		rotation.x += 0;
		rotation.y += 0.1;
		rotation.z += 0;
		viewer.rotMatrix.rotateAboutYAxis(rotation.y);
		viewer.rotMatrix.rotateAboutXAxis(rotation.x);
		viewer.rotMatrix.rotateAboutZAxis(rotation.z);
		// viewer.rotate(rotation.x, rotation.y, rotation.z);
		viewer.update();
	}
	setTimeout(update, 10);
}

	ElevationGrid = function(name) {
		this.name = (name != null) ? name : 'noname';
		this.xDim = 0;
		this.zDim = 0;
		this.xSpacing = 0;
		this.zSpacing = 0;
		this.heights = [];
		this.textureUrl = '';
		this.onDataLoaded = null;

		this.toMesh = function() {
			var mesh = new JSC3D.Mesh;
			mesh.name = this.name;
			if( this.xDim > 1 && this.zDim > 1 && 
				this.heights.length >= this.xDim * this.zDim ) {

				mesh.vertexBuffer = new Array(this.xDim * this.zDim * 3);
				var k = 0;
				for(var i=0; i<this.zDim; i++) {
					for(var j=0; j<this.xDim; j++) {
						mesh.vertexBuffer[k++] = j * this.xSpacing;
						mesh.vertexBuffer[k++] = this.heights[j + i * this.xDim];
						mesh.vertexBuffer[k++] = i * this.zSpacing;
					}
				}

				mesh.indexBuffer = new Array((this.xDim - 1) * (this.zDim - 1) * 4);
				k = 0;
				for(var i=0; i<this.zDim-1; i++) {
					for(var j=0; j<this.xDim-1; j++) {
						mesh.indexBuffer[k++] = j + i * this.xDim;
						mesh.indexBuffer[k++] = j + (i + 1) * this.xDim;
						mesh.indexBuffer[k++] = j + 1 + i * this.xDim;
						mesh.indexBuffer[k++] = -1;
						mesh.indexBuffer[k++] = j + (i + 1) * this.xDim;
						mesh.indexBuffer[k++] = j + 1 + (i + 1) * this.xDim;
						mesh.indexBuffer[k++] = j + 1 + i * this.xDim;
						mesh.indexBuffer[k++] = -1;
					}
				}

				if(this.textureUrl != '') {
					mesh.texCoordBuffer = new Array(this.xDim * this.zDim * 2);
					k = 0;
					for(var i=0; i<this.zDim; i++) {
						for(var j=0; j<this.xDim; j++) {
							mesh.texCoordBuffer[k++] = j / (this.xDim - 1);
							mesh.texCoordBuffer[k++] = i / (this.zDim - 1);
						}
					}

					mesh.texCoordIndexBuffer = mesh.indexBuffer;

					var texture = new JSC3D.Texture;
					texture.onready = function() {
						mesh.setTexture(this);
						viewer.update();
					};
					texture.createFromUrl(this.textureUrl);
				}
			}

			return mesh;
		};

		this.loadFromFile = function(filename) {
			var xhr;
			if (window.XMLHttpRequest) {
			    xhr = new XMLHttpRequest();
			} else if (window.ActiveXObject) {
			    xhr = new ActiveXObject("Microsoft.XMLHTTP");
			}

			xhr.parent = this;

			xhr.onreadystatechange = function(){ 
				if (xhr.readyState == 4 && xhr.status == 200) {
					console.log("DATA LOADED");
					var txt = xhr.responseText;
					var data = txt.split(',');
					for (var i = 0; i < data.length; i++) {
						data[i] = (parseFloat(data[i]))/20;
					};
					console.log("Data length: ", data.length);
					this.parent.heights = data;
					// console.log(data);
					if (this.parent.onDataLoaded != null) {
						console.log("ODL");
						this.parent.onDataLoaded();
					}
				}
			};
			xhr.open("GET", filename);
			xhr.send();
		};
	};

	var terrain = new ElevationGrid('terrain');
	terrain.xDim = 1024;
	terrain.zDim = 1024;
	terrain.xSpacing = .2;
	terrain.zSpacing = .2;
	terrain.textureUrl = 'eiger.jpg';

	var mesh = null;
	var mat = new JSC3D.Material();
	terrain.onDataLoaded = function() {

		mesh = terrain.toMesh();
		mat.simulateSpecular = true;
		mat.diffuseColor = 0xcfcfcf;
		mat.transparency = 0;
		mesh.setMaterial(mat);

		var scene = new JSC3D.Scene();
		scene.addChild(mesh);
		viewer.replaceScene(scene);


		viewer.zoomFactor = 8;
		update();
	};

	terrain.loadFromFile('eiger_height.dat');

  </script>
 </BODY>
</HTML>
